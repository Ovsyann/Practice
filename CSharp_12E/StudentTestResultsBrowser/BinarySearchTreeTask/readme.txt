1)сложность
в среднем
получение O(log(n))
поиск O(log(n))
добавление O(log(n))
удаление O(log(n))
в худшем все становится O(n), так как при плохой сортировке дерево превращается в массив.
2)расход памяти O(n)
3)сравнение структур
получение: быстрее-Array,List(обращение по индексу) медленнее-Stack,LinkedList,Dictionary(сравнение с каждым)
поиск: равная сложность
добавление: быстрее-Stack,LinkedList,Dictionary(добавление в конец) медленнее-Array,List(пересоздание)
удаление быстрее-Stack,LinkedList,Dictionary(удаление элемента) медленнее-Array,List(пересоздание)
